// avro consumer
docker exec -it schema-registry /usr/bin/kafka-avro-console-consumer --topic summed-rated-movies --bootstrap-server broker:9092 --from-beginning

// rating producer
docker exec -i schema-registry /usr/bin/kafka-avro-console-producer --topic ratings --broker-list broker:9092 --property value.schema="$(< src/main/avro/rating.avsc)"
// ratings
{"id": 294, "rating": 8.2}
{"id": 294, "rating": 8.5}
{"id": 354, "rating": 9.9}
{"id": 354, "rating": 9.7}
{"id": 782, "rating": 7.8}
{"id": 782, "rating": 7.7}
{"id": 128, "rating": 8.7}
{"id": 128, "rating": 8.4}
{"id": 780, "rating": 2.1}

// movie producer
docker exec -i schema-registry /usr/bin/kafka-avro-console-producer --topic movies --broker-list broker:9092 --property value.schema="$(< src/main/avro/movie.avsc)"
// movies
{"id": 294, "title": "Die Hard", "release_year": 1988}
{"id": 354, "title": "Tree of Life", "release_year": 2011}
{"id": 782, "title": "A Walk in the Clouds", "release_year": 1995}
{"id": 128, "title": "The Big Lebowski", "release_year": 1998}
{"id": 780, "title": "Super Mario Bros.", "release_year": 1993}

1)  implementare un semplice topK in locale

2)  calcolare i topk sulle singole partizioni
    unire i risultati in un topic senza partizione

3)  usare uno stato distribuito per estrapolare i topK

4)  implementare algoritmo: vedi se già c'è
    prima centralizzato senza partizioni
    poi con partizioni

score = rating/10 * 0.8 + release_year/2020 * 0.2

loggare tempi di esecuzione su ogni kstream

TASKS:
[ ] implementazione centralizzata di materialize score & sort
[ ] implementazione distributia di materialize score & sort
[ ] implementazione centralizzata di [1]
[ ] progettazione di implementazione distribuita di [1]

[1] D. Yang, A. Shastri, E.A. Rundensteiner and M.O. Ward,
Anoptimal strategy for monitoring top-k queries in streaming windows,
in:Proceedings of the 14th International Conference onExtending Database Technology, ACM, 2011, pp. 57–68.


